% Define Links
links = [Link(0, 0, -pi/2, 0), Link(0, 0.432, 0, 0), Link(0.149, -0.02, pi/2, 0), Link(0.433, 0, -pi/2, 0), Link(0, 0, pi/2, 0), Link(0, 0, 0, 0)];

% Define Joints
joints = [Joint(-160, 160), Joint(-125, 125), Joint(-135, 135), Joint(-140, 140), Joint(-100, 100), Joint(-260, 260)];

% Create Robot
myRobot = Robot(links, joints);

% A_cartesian
% [0.64, 0.77, 0, 0.05; 0.77, -0.64, 0, -0.55; 0, 0, -1, -0.6; 0, 0, 0, 1];
% A_joint
% [-100.4577   70.6108   48.3997         0   60.9896   29.2746];

% B_cartesian
% [0.87, -0.1, 0.48, 0.50; 0.29, 0.9, -0.34, -0.4; -0.4, 0.43, 0.81, 0.4; 0, 0, 0, 1];
% B_joint
% [-52.1158   -1.4358   30.2060 -121.3834  -11.4781 -176.7074];

% C_cartesian
% [0.41, -0.29, 0.87, 0.6; 0.69, 0.71, -0.09, 0.15; -0.6, 0.64, 0.49, -0.30; 0, 0, 0, 1];
% C_joint
% [0.0955   65.7969   14.3196   15.3377  -20.1730   29.2567];



% Main Loop
while true
    % Prompt for mode
    disp('===================================================================================');
    mode = input('Enter mode (j/c) or type ''exit'' to quit: ', 's');
    
    % Check for exit condition
    if strcmp(mode, 'exit')
        break;
    end
    
    % (a) Joint move
    if strcmp(mode, 'j')
        % Define the total time for each segment
        T = 0.5; % Time for A to B and B to C
        tacc = 0.2; % Acceleration/Deceleration time
        tsample = 0.002; % Sampling time

        % Define the joint positions
        A = [-100.4577, 70.6108, 48.3997, 0, 60.9896, 29.2746];
        B = [-52.1158   -1.4358   30.2060 -121.3834  -11.4781 -176.7074];
        C = [0.0955, 65.7969, 14.3196, 15.3377, -20.1730, 29.2567];

        % Time vector
        t_total = T * 2; % Total movement time
        t = 0:tsample:t_total;

        % Initialize the Joint arrays
        j = zeros(6, length(t)); % Joint position
        j_speed = zeros(6, length(t)); % Joint speed
        j_acc = zeros(6, length(t)); % Joint acceleration
        
        % Initialize the Cartesian arrays
        pos = zeros(3, length(t));      % Cartesian position
        ori = zeros(3, length(t));      % Cartesian orientation
        
        for i = 1:length(t)
            if t(i) <= T - tacc
                % Linear portion: A to A'
                j(:, i) = A + (B-A) ./ T .* t(i);
                j_speed(:, i) = (B-A) ./ T;
                j_acc(:, i) = zeros(6, 1);

            elseif t(i) < T + tacc
                % Transition portion
                Ac = A + (B-A) ./ T .* (T-tacc); % A'
                Bc = B + (C-B) ./ T .* tacc; % B'
                dB = Ac - B;
                dC = C - B;
                h = (t(i) - T + tacc) / (2 * tacc);
                j(:, i) = ((dC .* (tacc ./ T) + dB) .* (2 - h) .* h^2 - 2 .* dB) .* h + B + dB;
                j_speed(:, i) = ((dC .* (tacc ./ T) + dB) .* (1.5 - h) .* 2 .* h^2 - dB) ./ tacc;
                j_acc(:, i) = (dC .* (tacc ./ T) + dB) .* (1 - h) .* 3 .* h ./ (tacc^2);

            else
                % Linear portion: B' to C
                j(:, i) = B + (C-B) ./ T .* (t(i) - T);
                j_speed(:, i) = (C-B) ./ T;
                j_acc(:, i) = zeros(6, 1);
            end

            % Calculate Cartesian position
            [T6, euler_points] = myRobot.forwardKinematics(deg2rad(j(:, i))); % forwardKinematics
            pos(:, i) = euler_points(1:3) .* 100;
            ori(:, i) = T6(1:3, 3);

        end

        
        % Number of joints
        num_joints = 6;

        % Create figure for joint values
        draw_joints('value', t, j, num_joints);

        % Create figure for joint speeds
        draw_joints('speed', t, j_speed, num_joints);

        % Create figure for joint accelerations
        draw_joints('acc', t, j_acc, num_joints);

        % Create figure for cartesian path
        title_plot = '3D path of joint space planning';
        draw_cartesian_path(title_plot, pos, ori);

    % (b) Cartesian move
    elseif strcmp(mode, 'c')
        A = [0.64, 0.77, 0, 0.05; 0.77, -0.64, 0, -0.55; 0, 0, -1, -0.6; 0, 0, 0, 1];
        
        B = [0.87, -0.1, 0.48, 0.50; 0.29, 0.9, -0.34, -0.4; -0.4, 0.43, 0.81, 0.4; 0, 0, 0, 1];

        C = [0.41, -0.29, 0.87, 0.6; 0.69, 0.71, -0.09, 0.15; -0.6, 0.64, 0.49, -0.30; 0, 0, 0, 1];
        
        %---------------------- Linear portion: A to A' ------------------
        [x, y, z, psi, theta, phi] = find_solution(A, B);
        [trans_traj_AA2, pos_traj_AA2, ori_traj_AA2, len_traj_AA2] = linear_trajectory(T, tsample, tacc, A, 0, T-tacc, x, y, z, psi, theta, phi);
        
        %---------------------- Transition portion: A' to B' ------------------
        A2 = trans_traj_AA2(:, :, len_traj_AA2);
        [xA, yA, zA, psiA, thetaA, phiA] = find_solution(B, A2);
        
        [xC, yC, zC, psiC, thetaC, phiC] = find_solution(B, C);
        
        if abs(psiC - psiA) > pi/2
            psiA = psiA + pi;
            thetaA = -thetaA;
        end
        
        [trans_traj_A2B2, pos_traj_A2B2, ori_traj_A2B2, len_traj_A2B2] = trans_trajectory(T, tsample, tacc, B, -tacc+tsample, tacc-tsample, xA, yA, zA, psiA, thetaA, phiA, xC, yC, zC, psiC, thetaC, phiC);
        
        %---------------------- Linear portion: B' to C ------------------
        [trans_traj_B2C, pos_traj_B2C, ori_traj_B2C, len_traj_B2C] = linear_trajectory(T, tsample, tacc, B, tacc, T, xC, yC, zC, psiC, thetaC, phiC);
        
        pos_traj_AA2 = pos_traj_AA2 .* 100;
        pos_traj_A2B2 = pos_traj_A2B2 .* 100;
        pos_traj_B2C = pos_traj_B2C .* 100;
        
        % Create figure for cartesian values
        t = 0:tsample:2*T;
        
        cx = [pos_traj_AA2(1, :) pos_traj_A2B2(1, :) pos_traj_B2C(1, :)];
        cy = [pos_traj_AA2(2, :) pos_traj_A2B2(2, :) pos_traj_B2C(2, :)];
        cz = [pos_traj_AA2(3, :) pos_traj_A2B2(3, :) pos_traj_B2C(3, :)];
        c = [cx; cy; cz];
        disp(['3 elements of cx: ', num2str(cx(len_traj_AA2-1:len_traj_AA2+1))]);
        
        draw_cartesian('value', t, c);

        % Create figure for cartesian velocity
        dt = t(2:length(t));
        dcx = (cx(2:end) - cx(1:end-1)) / tsample;
        dcy = (cy(2:end) - cy(1:end-1)) / tsample;
        dcz = (cz(2:end) - cz(1:end-1)) / tsample;
        dc = [dcx; dcy; dcz];
        disp(['3 elements of dcx: ', num2str(dcx(len_traj_AA2-1:len_traj_AA2+1))]);

        draw_cartesian('speed', dt, dc);


        % Create figure for cartesian accelerations
        dt2 = t(3:length(t));
        dc2x = (dcx(2:end) - dcx(1:end-1)) / tsample;
        dc2y = (dcy(2:end) - dcy(1:end-1)) / tsample;
        dc2z = (dcz(2:end) - dcz(1:end-1)) / tsample;
        dc2 = [dc2x; dc2y; dc2z];

        draw_cartesian('acc', dt2, dc2);


        % Create figure for cartesian path
        title_plot = '3D path of cartesian space planning';
        pos = c;
        ori = [ori_traj_AA2(1, :), ori_traj_A2B2(1, :), ori_traj_B2C(1, :);
             ori_traj_AA2(2, :), ori_traj_A2B2(2, :), ori_traj_B2C(2, :);
             ori_traj_AA2(3, :), ori_traj_A2B2(3, :), ori_traj_B2C(3, :)];
        
        draw_cartesian_path(title_plot, pos, ori);

    else
        disp('Invalid mode. Please enter ''j'' or ''c''.');
    end
end

function draw_joints(type, t, j, num_joints)
    if strcmp(type, 'value')
        title_plot = 'Joint Values';
        yl = 'angle (degree)';
    elseif strcmp(type, 'speed')
        title_plot = 'Joint Speeds';
        yl = 'angular velocity (degree/s)';
    elseif strcmp(type, 'acc')
        title_plot = 'Joint Accelerations';
        yl = 'angular acceleration (degree/s²)';
    else
        title_plot = '';
        yl = '';
        disp('Wrong type !!!');
    end
    
    figure('Name', title_plot)
    for i = 1:num_joints
        subplot(3, 2, i);
        plot(t, j(i, :));
        title(['θ', num2str(i)]);
        if i == 5 || i == 6 % bottom row
            xlabel('time (s)');
        end
        if i == 3 % left column
            ylabel(yl);
        end
    end
end

function draw_cartesian(type, t, c)
    if strcmp(type, 'value')
        title_plot = 'Position of xyz';
        yl = 'Position(cm)';
    elseif strcmp(type, 'speed')
        title_plot = 'Velocity of xyz';
        yl = 'Velocity(cm/s)';
    elseif strcmp(type, 'acc')
        title_plot = 'Accleration of xyz';
        yl = 'Acceleration(cm/s²)';
    else
        title_plot = '';
        yl = '';
        disp('Wrong type !!!');
    end
    
    figure('Name', title_plot)
    for i = 1:3
        subplot(3, 1, i);
        plot(t, c(i, :));
        if i == 3 % bottom row
            xlabel('time (s)');
        end
        if i == 2 % left column
            ylabel(yl);
        end
    end
    
end

function draw_cartesian_path(title_plot, pos, ori)
    
    figure('Name',title_plot);

    % Plot and label points A, B, C
    A_cartesian = [5, -55, -60];
    B_cartesian = [50, -40, 40];
    C_cartesian = [60, 15, -30];
        
    plot3(A_cartesian(1), A_cartesian(2), A_cartesian(3), 'go'); % Point A in light green
    text(A_cartesian(1), A_cartesian(2), A_cartesian(3), ' A(5, -55, -60)');
    hold on;

    plot3(B_cartesian(1), B_cartesian(2), B_cartesian(3), 'mo'); % Point B in purple
    text(B_cartesian(1), B_cartesian(2), B_cartesian(3), '  B(50, -40, 40)');
    hold on;

    plot3(C_cartesian(1), C_cartesian(2), C_cartesian(3), 'ro'); % Point C in orange
    text(C_cartesian(1), C_cartesian(2), C_cartesian(3), '  C(60, 15, -30)');
    hold on;

    quiver3(pos(1,:), pos(2,:), pos(3,:), ori(1,:), ori(2,:), ori(3,:), 'c', 'LineWidth', 0.5); % Plot orientation vectors
    plot3(pos(1,:), pos(2,:), pos(3,:), 'bl-o', 'MarkerSize', 1); % Plot trajectory
    hold on;

    % Set labels and title
    xlabel('x (cm)');
    ylabel('y (cm)');
    zlabel('z (cm)');
    grid on;
    hold off;
end

% Method to find solutions
function [x, y, z, psi, theta, phi] = find_solution(from, to)
    % Extract columns from A and B
    n1 = from(:, 1);
    o1 = from(:, 2);
    a1 = from(:, 3);
    p1 = from(:, 4);

    n2 = to(:, 1);
    o2 = to(:, 2);
    a2 = to(:, 3);
    p2 = to(:, 4);

    % Find solutions for x, y, z
    x = dot(n1, (p2 - p1));
    y = dot(o1, (p2 - p1));
    z = dot(a1, (p2 - p1));

    % Find solution for psi
    psi = atan2(dot(o1, a2), dot(n1, a2));

    % Find solution for theta
    theta = atan2(sqrt(dot(n1, a2)^2 + dot(o1, a2)^2), dot(a1, a2));

    % Find solution for phi
    s_psi = sin(psi);
    c_psi = cos(psi);
    v_theta = 1 - cos(theta);
    s_theta = sin(theta);
    c_theta = cos(theta);
    s_phi = -s_psi * c_psi * v_theta * dot(n1, n2) + ((c_psi)^2 * v_theta + c_theta) * dot(o1, n2) - s_psi * s_theta * dot(a1, n2);
    c_phi = -s_psi * c_psi * v_theta * dot(n1, o2) + ((c_psi)^2 * v_theta + c_theta) * dot(o1, o2) - s_psi * s_theta * dot(a1, o2);
    phi = atan2(s_phi, c_phi);
end

% Method for linear trajectory
function [trans_traj, pos_traj, ori_traj, len_traj] = linear_trajectory(T, tsample, tacc, from, t_start, t_end, x, y, z, psi, theta, phi)
    % Define time vector
    t = t_start:tsample:t_end;
    len_traj = length(t);

    % Preallocate trajectory matrices
    trans_traj = zeros(4, 4, len_traj);
    pos_traj = zeros(3, len_traj);
    ori_traj = zeros(3, len_traj);

    for i = 1:length(t)
        r = t(i) / T;
        r_x = x * r;
        r_y = y * r;
        r_z = z * r;
        r_theta = theta * r;
        r_phi = phi * r;

        s_psi = sin(psi);
        c_psi = cos(psi);
        v_r_theta = 1 - cos(r_theta);
        s_r_theta = sin(r_theta);
        c_r_theta = cos(r_theta);
        s_r_phi = sin(r_phi);
        c_r_phi = cos(r_phi);

        Tr = [ 1, 0, 0, r_x;
               0, 1, 0, r_y;
               0, 0, 1, r_z;
               0, 0, 0, 1 ];

        Ra = [s_psi^2 * v_r_theta + c_r_theta, -s_psi * c_psi * v_r_theta     , c_psi * s_r_theta, 0;
              -s_psi * c_psi * v_r_theta     , c_psi^2 * v_r_theta + c_r_theta, s_psi * s_r_theta, 0;
              -c_psi * s_r_theta             , -s_psi * s_r_theta             , c_r_theta        , 0;
               0                             , 0                              , 0                , 1];

        Ro = [c_r_phi, -s_r_phi,  0, 0 ;
              s_r_phi, c_r_phi ,  0, 0 ;
               0     , 0       ,  1, 0 ;
               0     , 0       ,  0, 1];

        Dr = Tr * Ra * Ro;
        trans_traj(:, :, i) = from * Dr;
        pos_traj(:, i) = trans_traj(1:3, 4, i);
        ori_traj(:, i) = trans_traj(1:3, 3, i);

    end
end

% Method for transition trajectory
function [trans_traj, pos_traj, ori_traj, len_traj] = trans_trajectory(T, tsample, tacc, from, t_start, t_end, xA, yA, zA, psiA, thetaA, phiA, xC, yC, zC, psiC, thetaC, phiC)
    % Define time vector
    t = t_start:tsample:t_end;
    len_traj = length(t);

    % Preallocate trajectory matrices
    trans_traj = zeros(4, 4, len_traj);
    pos_traj = zeros(3, len_traj);
    ori_traj = zeros(3, len_traj);

    for i = 1:length(t)
        h = (t(i) + tacc) / (2 * tacc);
        dx = ((xC * (tacc / T) + xA) * (2 - h) * h^2 - 2 * xA) * h + xA;
        dy = ((yC * (tacc / T) + yA) * (2 - h) * h^2 - 2 * yA) * h + yA;
        dz = ((zC * (tacc / T) + zA) * (2 - h) * h^2 - 2 * zA) * h + zA;
        dpsi = (psiC - psiA) * h + psiA;
        dtheta = ((thetaC * (tacc / T) + thetaA) * (2 - h) * h^2 - 2 * thetaA) * h + thetaA;
        dphi = ((phiC * (tacc / T) + phiA) * (2 - h) * h^2 - 2 * phiA) * h + phiA;

        s_psi = sin(dpsi);
        c_psi = cos(dpsi);
        v_theta = 1 - cos(dtheta);
        s_theta = sin(dtheta);
        c_theta = cos(dtheta);
        s_phi = sin(dphi);
        c_phi = cos(dphi);

        Tr = [ 1, 0, 0, dx;
               0, 1, 0, dy;
               0, 0, 1, dz;
               0, 0, 0, 1 ];

        Ra = [s_psi^2 * v_theta + c_theta  , -s_psi * c_psi * v_theta     , c_psi * s_theta, 0;
              -s_psi * c_psi * v_theta     , c_psi^2 * v_theta + c_theta  , s_psi * s_theta, 0;
              -c_psi * s_theta             , -s_psi * s_theta             , c_theta        , 0;
               0                           , 0                            , 0              , 1];

        Ro = [c_phi, -s_phi    ,  0, 0 ;
              s_phi, c_phi     ,  0, 0 ;
               0     , 0       ,  1, 0 ;
               0     , 0       ,  0, 1];

        Dr = Tr * Ra * Ro;
        trans_traj(:, :, i) = from * Dr;
        pos_traj(:, i) = trans_traj(1:3, 4, i);
        ori_traj(:, i) = trans_traj(1:3, 3, i);

    end
end